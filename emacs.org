#+TITLE: Tom's Emacs Configuration
#+AUTHOR: Tom Small <tsmall3@gmail.com>

* Introduction

Welcome to my Emacs configuration file. This file contains a lot of changes
I've made over many years of using Emacs. It contains my own code and code
others have shared online. I've included credit for the authors of most of the
shared code, though I'm sure I've missed some. I'm sorry if I missed you. But
please let me know and I'll correct it!

* Organization of this document

This file is written in Babel for Org mode, in a literate programming style.
That way I can organize it for the reader and not the computer, using all of
the markup tools Org mode provides to describe the program right along with the
code itself.

This document is organized from the general to the specific. It's broken up
into many small sections, to make it easy to jump right to the section you're
interested. But it's also written to be read from beginning to end.

First are the settings that apply to Emacs as a whole (see [[*Emacs settings][Emacs settings]]).
These are things like the size of the window at startup, the fonts to use,
and making the cursor not blink.

Then it focuses on settings that apply to specific modes (see [[*Mode-specific settings][Mode-specific
settings]]). This section has one sub-section per mode.

The next section describes some of the helper methods I've found and created
over time (see [[*Helpers and utilities][Helpers and utilities]]). These are little utilities to make
everyday text editing just a bit more pleasant.

Lastly, it combines all of the code together into a single file that we'll
configure Emacs to load at startup (see [[*Putting%20it%20all%20together][Putting it all together]]).

* Emacs settings
:PROPERTIES:
:header-args: :noweb-ref emacs-settings
:END:

This section defines the customizations that apply to Emacs as a whole.

** Sensible defaults

I disagree with many of Emacs's default settings. Who wants their cursor to
blink? That's just distracting. We don't need two spaces after a sentence.
That's just wasteful. Let's put things the way they should be.

#+BEGIN_SRC elisp
  (setq transient-mark-mode t)            ; Highlight regions
  (setq line-number-mode t)               ; Display line numbers
  (setq column-number-mode t)             ; Display column numbers
  (blink-cursor-mode 0)                   ; Don't blink the cursor
  (setq visible-bell nil)                 ; Disable beep
  (setq confirm-kill-emacs 'yes-or-no-p)  ; Confirm quit
  (tool-bar-mode -1)                      ; Disable tool bar
  (set-scroll-bar-mode nil)               ; Hide the scroll bars
  (fset 'yes-or-no-p 'y-or-n-p)           ; Make answering yes or no easier
  (setq-default fill-column 79)           ; Wrap at 79 columns by default
  (setq sentence-end-double-space nil)    ; Let one space end a sentence
#+END_SRC

** Fonts

One of my top interests is typography. So I end up switching which font I use
in my text editors and IDEs often. This is my latest combination:

#+BEGIN_SRC elisp
  (trs/set-default-font "Menlo" 120)
  (trs/set-variable-font "Helvetica" 120)
#+END_SRC

Some of those fonts have ligatures for common coding character combinations
commonly (like ->). Stock Emacs doesn't have support for that, though. So to
have them work in Emacs, I need to use the [[https://github.com/railwaycat/homebrew-emacsmacport][railwaycat Emacs port]] and enable
this setting:

#+BEGIN_SRC elisp
  (if (boundp 'mac-auto-operator-composition-mode)
      (mac-auto-operator-composition-mode))
#+END_SRC

** Tabs vs. spaces

Ahh, the age-old debate. Should you use spaces or tabs to indent your code? If
you use spaces, how many? Honestly, I'm a bit tired of this debate. I'll use
whatever a project has decided, or whatever the standard is for a language.
(This is also one of the reasons I really like Go and Lisps: there's one way to
format your code, and that's it.)

But it seems like, in general, four spaces has won. And that seems like a
reasonable default to me. So four spaces it is.

#+BEGIN_SRC elisp
  (setq-default tab-width 4)              ; Interpret tab char as 4 places
  (setq-default indent-tabs-mode nil)     ; Insert spaces instead of tabs
#+END_SRC

** Ido-mode

Ido-mode makes it much easier to switch buffers, open files, and to do many of
the things you do many times a day. It does that by showing all of your options
and letting you choose one with fewer keystrokes with fuzzy matching.

#+BEGIN_SRC elisp
  (ido-mode t)                            ; Turn on ido-mode
  (setq ido-enable-flex-matching t)       ; Turn on flexible matching
  (setq-default Man-width fill-column)    ; Wrap man pages at fill-column
#+END_SRC

** "Uniquify" buffers

In some projects it's very likely that you'll end up with multiple files opened
with the exact same filename. In a Python project, for example, every package
has a =__init__.py= file. By default Emacs appends a number to the file's buffer
name to make it unique. But that doesn't really help you tell which is which.

Luckily there's a built-in package named =uniquify= that solves this problem. It
lets you choose alternative ways to differentiate buffers for identical
filenames. I've chosen to have it prepend a portion of the file's path.

#+BEGIN_SRC elisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Startup window size

I like to have Emacs start up with a slightly bigger window that it has by
default.

#+BEGIN_SRC elisp
  (add-to-list 'default-frame-alist '(height . 35))
  (add-to-list 'default-frame-alist '(width . 115))
#+END_SRC

** OS X settings

There are a few tweaks needed for Emacs to work as expected on OS X. The
biggest for me is a preference: using the Command key as the meta modifier. (I
also map the Caps Lock key to Control, but that's outside the scope of Emacs.)

The other big fix is about how the =$PATH= is set up. Programs launched from the
Finder don't have the bash =$PATH= settings applied. Luckily someone else has
already fixed that problem for us. We just have to call
~exec-path-from-shell-initialize~.

#+BEGIN_SRC elisp
  (when (eq system-type 'darwin)
    (setq mac-option-key-is-meta nil
          mac-command-key-is-meta t
          mac-command-modifier 'meta
          mac-option-modifier 'none)

    (exec-path-from-shell-initialize))
#+END_SRC

* Mode-specific settings
:PROPERTIES:
:header-args: :noweb-ref mode-specific-settings
:END:

The following subsections define mode-specific customizations.

** Ace Jump mode

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "M-C-j") 'ace-jump-mode)
#+END_SRC

** C mode

I don't work with C much, so I haven't felt the need to change much here. But
many other modes are based on =c-mode=, so setting the indentation offset there
applies to many of the other modes I /do/ use more often.

#+BEGIN_SRC elisp
  (setq c-basic-offset 4)
#+END_SRC

** Clojure / ClojureScript mode

*** Compojure

These indentation rules teach clojure-mode how to handle route code.
They're taken from the [[https://github.com/weavejester/compojure/wiki/Emacs-indentation][Compojure wiki]].

It requires using a macro defined in clojure-mode,
so first we have to require clojure-mode
to bring that macro into existence.

#+BEGIN_SRC elisp
  (require 'clojure-mode)
#+END_SRC

Then we can set up the indentation.

#+BEGIN_SRC elisp
  (define-clojure-indent
    (defroutes 'defun)
    (GET 2)
    (POST 2)
    (PUT 2)
    (DELETE 2)
    (HEAD 2)
    (ANY 2)
    (context 2))
#+END_SRC

*** Hoplon

These configs come from the [[https://github.com/hoplon/hoplon/wiki/For-Emacs-users][Hoplon Emacs configuration instructions]].

First, we need to teach Emacs that files ending with =.cljs.hl= are actually
ClojureScript files.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.cljs\\.hl\\'" . clojurescript-mode))
#+END_SRC

Then we need to teach it how to properly indent Hoplon's macros:

#+BEGIN_SRC elisp
  (add-hook 'clojure-mode-hook
            '(lambda ()
               ;; Hoplon functions and macros
               (dolist (pair '((page . 'defun)
                               (loop-tpl . 'defun)
                               (if-tpl . '1)
                               (for-tpl . '1)
                               (case-tpl . '1)
                               (cond-tpl . 'defun)))
                 (put-clojure-indent (car pair)
                                     (car (last pair))))))
#+END_SRC

** EditorConfig

Turn on EditorConfig support.

#+BEGIN_SRC elisp
  (editorconfig-mode 1)
#+END_SRC

** Expand Region

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-=") 'er/expand-region)
#+END_SRC

** Fiplr

Bind fiplr's find file mode to a convenient keyboard shortcut:

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c t") 'fiplr-find-file)
#+END_SRC

Tell fiplr to ignore any source control files,
and a few other file types that shouldn't show up too.

#+BEGIN_SRC elisp
  (setq fiplr-ignored-globs
        '((directories
           (".git" ".svn" ".hg" ".bzr"
            "bower_components" "node_modules"))
          (files
           (".#*" "*~" "*.so"
            "*.jpg" "*.png" "*.gif"
            "*.gz" "*.pdf" "*.pyc" "*.zip"))))
#+END_SRC

** Haskell

Turn on a few of haskell-mode's useful features:

#+BEGIN_SRC elisp
  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
#+END_SRC

** Highlight Symbol

Set up key bindings:

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key [f3]                 'highlight-symbol-next)
  (global-set-key [(shift f3)]         'highlight-symbol-prev)
  (global-set-key [(control f3)]       'highlight-symbol-at-point)
  (global-set-key [(control meta f3)]  'highlight-symbol-query-replace)
  (global-set-key [(control shift f3)] 'highlight-symbol-remove-all)
#+END_SRC

** HTML mode

The HTML mode is based on =sgml-mode=, which defines its own variable for
indentation. I'll use 4 spaces for indentation there.

#+BEGIN_SRC elisp
  (setq sgml-basic-offset 4)
#+END_SRC

** iy-go-to-char

This mode teaches Emacs about a very efficient navigation feature
that I first enountered in Vim:
jumping to the next (or previous) occurance of a character.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c f") 'iy-go-to-char)
  (global-set-key (kbd "C-c F") 'iy-go-to-char-backward)
  (global-set-key (kbd "C-c ;") 'iy-go-to-char-continue)
  (global-set-key (kbd "C-c ,") 'iy-go-to-char-continue-backward)
#+END_SRC

** js2-mode

I like js2-mode more than the default JavaScript mode,
so we'll teach Emacs to always use it for =.js= files.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+END_SRC

Sometimes I like using the no-semicolon style,
and I don't want js2-mode to tell me my code is wrong
when I do that.

#+BEGIN_SRC elisp
  (setq js2-strict-missing-semi-warning nil)
  (setq js2-missing-semi-one-line-override nil)
  (setq js2-strict-trailing-comma-warning nil)
#+END_SRC

** Multiple Cursors

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-M->") 'mc/skip-to-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-M-<") 'mc/skip-to-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
  (global-set-key (kbd "C-c C->") 'mc/mark-all-like-this)

  (global-set-key (kbd "C-c C-r") 'mc/edit-lines)
  (global-set-key (kbd "M-<kp-enter>") 'set-rectangular-region-anchor)
#+END_SRC

** PHP mode

When working with Drupal code,
some PHP code is in files with different extensions.
So we need to teach Emacs about them.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.inc$" . php-mode))
  (add-to-list 'auto-mode-alist '("\\.install$" . php-mode))
  (add-to-list 'auto-mode-alist '("\\.module$" . php-mode))
#+END_SRC

** Web mode

Web mode is the best solution I've found so far for working with HTML files,
which can contain other languages embedded inside it (e.g. JS or CSS).

Teach Emacs to always use web-mode for =.html= files:

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
#+END_SRC

Then tweak web-mode's indentation settings to match the style I use.

#+BEGIN_SRC elisp
  (setq web-mode-markup-indent-offset 4
        web-mode-css-indent-offset 4
        web-mode-code-indent-offset 4
        web-mode-style-padding 4
        web-mode-script-padding 4
        web-mode-block-padding 4)
#+END_SRC

** yasnippet

#+BEGIN_SRC elisp
  (yas-global-mode 1)
#+END_SRC

* Org Mode
:PROPERTIES:
:header-args: :noweb-ref org-mode-settings
:END:

Org Mode is basically an application on its own. So rather than hiding it
inside the [[*Mode-specific%20settings][Mode-specific settings section]], I'm promoting these settings to
their own section.

** Initialization

Org Mode is designed to be modular. That way features that are only used by
some are not built in to the core. I've started to go outside the default
modules, so I need to turn those on when setting up Org Mode.

#+BEGIN_SRC elisp :noweb yes
  (require 'org)
  <<org-modules>>
#+END_SRC

Automatically turn on Org Mode whenever opening a file with the =.org=
extension. Also turn on =olivetti-mode=, which I just find to be a more pleasant
writing environment for non-code files.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
  (add-hook 'org-mode-hook 'olivetti-mode)
#+END_SRC

** General behavior

Hide the emphasis markers to make the text more like a live preview.

#+BEGIN_SRC elisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

Indent bullets to make the hierarchy easier to see.

#+BEGIN_SRC elisp
  (setq org-startup-indented t)
#+END_SRC

Leave blank lines in between sections when they're folded. (I don't love having
them there always, but the default behavior is often confusing to me; I never
know where the blank lines are going to end up when moving things around.)

#+BEGIN_SRC elisp
  (setq org-cycle-separator-lines 1)
#+END_SRC

** Editing behavior

Don't split the line when the cursor is in the middle of it and I press
=M-Return=.

#+BEGIN_SRC elisp
  (setq org-M-RET-may-split-line nil)
#+END_SRC

Leave the content under a folded heading intact when inserting a new heading
via =M-Return=.

#+BEGIN_SRC elisp
  (setq org-insert-heading-respect-content t)
#+END_SRC

When working with a folded org file, it can be easy to accidentally clobber
some of the folded content. I'd rather be explicit about that, and have Org
Mode prevent me from doing it.

#+BEGIN_SRC elisp
  (setq org-catch-invisible-edits 'error)
#+END_SRC

** Faces

Tell Org Mode to enable custom fonts for headlines marked "done" so I can style
them in my themes.

#+BEGIN_SRC elisp
  (setq org-fontify-done-headline t)
#+END_SRC

** Todo settings

Mark the date and time I finish every task.

#+BEGIN_SRC elisp
  (setq org-log-done 'time)
#+END_SRC

Don't let me mark a todo item as done if it has children that aren't done.

#+BEGIN_SRC elisp
  (setq org-enforce-todo-dependencies t)
#+END_SRC

If I've set access keys for todo states (for example, =TODO(t)=), then make it
easy to use those shortcut keys whenever I set a todo state.

#+BEGIN_SRC elisp
  (setq org-use-fast-todo-selection t)
#+END_SRC

When switching between todo states with the /S-cursor/ (shift key plus the left
or right arrow keys), don't trigger any state change events. This makes it easy
to cycle between them quickly.

#+BEGIN_SRC elisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

Start warning me of upcoming deadlines 7 days in advance.

#+BEGIN_SRC elisp
  (setq org-deadline-warning-days 7)
#+END_SRC

Define a "stuck" project as one that is a "PROJ" todo item with no subtasks of
the "TODO" or "WAIT" types.

#+BEGIN_SRC elisp
  (setq org-stuck-projects '("TODO=\"PROJ\"" ("TODO" "WAIT") nil ""))
#+END_SRC

** Default todo keywords

These are often overridden on a per-file basis, but set a useful set of default
todo keywords so I don't /have/ to set them for every file.

#+BEGIN_SRC elisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "STRT(s)" "WAIT(w)" "|" "DONE(d)" "CNCL(c)")))
#+END_SRC

** Capturing

By default, capture things to my inbox file.

#+BEGIN_SRC elisp
  (setq org-default-notes-file (concat org-directory "/inbox.org"))
#+END_SRC

Some templates go directly to my todo file though.

#+BEGIN_SRC elisp
  (defvar trs/org-todo-file
    (concat org-directory "/todo.org"))
#+END_SRC

I have a few different templates, defined below.

#+BEGIN_SRC elisp :noweb yes
  (setq org-capture-templates
        '(
           <<org-capture-templates>>
         ))
#+END_SRC

Capture inbox notes to my inbox file.

#+BEGIN_SRC elisp :noweb-ref org-capture-templates
  ("i" "Inbox" entry (file org-default-notes-file)
   "* %?\n")
#+END_SRC

Sometimes I can jump past the inbox and create a one-off todo directly.

#+BEGIN_SRC elisp :noweb-ref org-capture-templates
  ("t" "Todo" entry (file+headline trs/org-todo-file "One-offs")
   "* TODO %?\n")
#+END_SRC

Make it easy to capture things I want to read. This template assumes the
thing's URL is on the clipboard, and automatically creates a link to it.

#+BEGIN_SRC elisp :noweb-ref org-capture-templates
  ("r" "Read Later" entry (file+headline trs/org-todo-file "Short Reads")
   "* TODO %? [[[%c][%^{linkdesc|site}]]]\n")
#+END_SRC

** Refiling

Target every todo item with the "PROJ" tag and every heading in the current file up to the 2nd level when refiling.

#+BEGIN_SRC elisp
  (setq org-refile-targets '((nil :todo . "PROJ")
                             (nil :maxlevel . 2)))
#+END_SRC

** Agenda

*** Files

Include all files in my =~/org= directory in my agenda.

#+BEGIN_SRC elisp
  (setq org-agenda-files '("~/org"))
#+END_SRC

*** Behavior

Show the agenda in the current window.

#+BEGIN_SRC elisp
  (setq org-agenda-window-setup 'current-window)
#+END_SRC

Don't use compact blocks; it's easier to scan when they have separators.

#+BEGIN_SRC elisp
  (setq org-agenda-compact-blocks nil)
#+END_SRC

If a task is blocked, don't show it in the agenda.

#+BEGIN_SRC elisp
  (setq org-agenda-dim-blocked-tasks 'invisible)
#+END_SRC

Don't show any tasks that are scheduled for the future in any of my todo lists.

#+BEGIN_SRC elisp
  (setq org-agenda-todo-ignore-scheduled 'future)
  (setq org-agenda-tags-todo-honor-ignore-options t)
#+END_SRC

Move the tags further to the right, to allow more space for the item text.

#+BEGIN_SRC elisp
  (setq org-agenda-tags-column -105)
#+END_SRC

*** Views

The custom agenda commands defined below will be all combined here to define the =org-agenda-custom-commands= variable.

#+BEGIN_SRC elisp :noweb tangle
  <<org-agenda-view-functions>>
  (setq org-agenda-custom-commands
        `(("o" "Overview" ,@(trs/org-agenda-views/overview))
          ("f" "Flagged Projects" ,@(trs/org-agenda-views/flagged-projects))))
#+END_SRC

**** Helper Functions

This function tells Org mode to skip a todo if it is scheduled for some time in the future. (After all, that's why I scheduled it: I don't want to think about it until then.)

#+BEGIN_SRC elisp
  (defun trs/org-agenda-skip-if-scheduled-for-later ()
    "If this function returns nil, the current match should not be skipped.
  Otherwise, the function must return a position from where the search
  should be continued."
    (ignore-errors
      (let ((subtree-end (save-excursion (org-end-of-subtree t)))
            (scheduled-seconds (time-to-seconds
                                (org-time-string-to-time
                                 (org-entry-get nil "SCHEDULED"))))
            (now (time-to-seconds (current-time))))
        (and scheduled-seconds
             (>= scheduled-seconds now)
             subtree-end))))
#+END_SRC

**** Overview

My most important view is my "overview". It's my command center. It is intended
to give me all the information I need to make a decision about what to do next.

#+BEGIN_SRC elisp :noweb-ref org-agenda-view-functions
  (defun trs/org-agenda-views/overview ()
    '(((agenda ""
               ((org-agenda-overriding-header "Today:")
                (org-agenda-span 'day)
                (org-agenda-skip-deadline-if-done t)
                (org-agenda-skip-scheduled-if-done t)))
       (tags-todo "+TODO=\"STRT\""
                  ((org-agenda-overriding-header "Started:")))
       (tags-todo "@errand"
                  ((org-agenda-overriding-header "Errands:")))
       (tags-todo "+TODO=\"TODO\"-@errand-read-watch"
                  ((org-agenda-overriding-header "Tasks:")))
       (todo "WAIT"
             ((org-agenda-overriding-header "Waiting For:")))
       (tags-todo "read|watch"
                  ((org-agenda-overriding-header "Content Queue:"))))

      ;; These settings apply to all of the above.
      ((org-agenda-skip-scheduled-if-deadline-is-shown t)
       (org-agenda-todo-ignore-scheduled t))))
#+END_SRC

**** Flagged Projects

Since these projects should be "blocked" -- they should all have TODO items
inside them -- I temporarily override the setting that would otherwise hide
them in agenda views.

#+BEGIN_SRC elisp :noweb-ref org-agenda-view-functions
  (defun trs/org-agenda-views/flagged-projects ()
    '(tags-todo
      "P1+TODO=\"PROJ\""
      ((org-agenda-dim-blocked-tasks nil))))
#+END_SRC

** Habit tracking

I've started using Org Mode's /habit/ module to track some of my recurring tasks
that have looser recurring dates. One very nice feature of this module is that
it shows a little graph next to the item in the agenda that shows how well I've
done the habit.

To start, we need to turn on the module.

#+BEGIN_SRC elisp :noweb-ref org-modules
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
#+END_SRC

Move the habit graphs further to the right in my agenda views, to leave more space for the actual item's text.

#+BEGIN_SRC elisp
  (setq org-habit-graph-column 65)
#+END_SRC

* Helpers and utilities
:PROPERTIES:
:header-args: :noweb-ref custom-functions
:noweb-sep: "\n\n"
:END:

The following subsections define custom functions I've written to make my life
in Emacs just a little bit nicer. They are all in the "/trs/ namespace", meaning
I've prefixed them all with =trs/=.

** Increment number at point

This function is taken verbatim from [[http://www.emacswiki.org/emacs/IncrementNumber][the Emacs wiki]]. It increments the number
underneath the pointer. By default it increments the number by 1, but that can
be overriden in the standard Emacs way by pressing =C-u= followed by a number.

The biggest benefit of having this function is in macros. Often when you copy a
line with a number in it, you want that number incremented on the next line.
But you need to define your macro generically; if it changes the number to a
specific value then all the lines will have that new value. This function
solves that problem.

#+BEGIN_SRC elisp
  (defun trs/increment-number-decimal (&optional arg)
    "Increment the number forward from point by 'arg'."
    (interactive "p*")
    (save-excursion
      (save-match-data
        (let (inc-by field-width answer)
          (setq inc-by (if arg arg 1))
          (skip-chars-backward "0123456789")
          (when (re-search-forward "[0-9]+" nil t)
            (setq field-width (- (match-end 0) (match-beginning 0)))
            (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
            (when (< answer 0)
              (setq answer (+ (expt 10 field-width) answer)))
            (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                   answer)))))))
#+END_SRC

I bind this function to a simple keystroke to make using it even easier.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c i") 'trs/increment-number-decimal)
#+END_SRC

** Fonts and typography

I'm a bit nuts about fonts, and tend to change my preferred font quite often.
So I've made it easy for me to switch between them.

See [[*Fonts][Fonts]] to see where I'm using these functions.

#+BEGIN_SRC elisp
  (defun trs/set-default-font (family &optional height weight)
    "Set the default font."
    (dolist (font-name (list 'default 'fixed-pitch-serif))
      (set-face-attribute font-name nil
                          :family family
                          :height (or height 100)
                          :weight (or weight 'medium))))

  (defun trs/set-variable-font (family &optional height weight)
    "Set the variable width font."
    (set-face-attribute 'variable-pitch nil
                        :family family
                        :height (or height 100)
                        :weight (or weight 'medium)))
#+END_SRC

** Clear the buffer

I've found it very useful to be able to easily clear the current buffer. You
can do this by moving to the beginning, starting selection, moving to the end,
and cutting the text. But that's a lot of work for something I do often.
Instead, I've created my own function that does what I need for me.

#+BEGIN_SRC elisp
  (defun trs/clear-buffer ()
    "Clear the contents of the current buffer."
    (interactive)
    (delete-region 1 (point-max)))
#+END_SRC

I bind this function to an easy to type key combo that's become muscle memory
for me now.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c l") 'trs/clear-buffer)
#+END_SRC

** Copy full buffer

In addition to clearing the buffer, it's often useful to copy the entire text
of the buffer into the clipboard. Like with [[*Clear%20the%20buffer][clearing]], I could do this manually.
But this is easier.

#+BEGIN_SRC elisp
  (defun trs/copy-buffer-to-clipboard ()
    "Copy the entire contents of the current buffer to the clipboard."
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max))
    (message "Copied."))
#+END_SRC

I bind this to a key command to make using it easy.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c w") 'trs/copy-buffer-to-clipboard)
#+END_SRC

** Separator line

I find it useful to be able to break up long source code files into sections.
This is a kind of poor man's literate programming. I use a line of "-"
characters to indicate section breaks. The following function does all the work
of creating that text for me.

#+BEGIN_SRC elisp
  (defun trs/insert-separator-line ()
    "Insert '-' characters from point to column 80."
    (interactive)
    (insert (make-string (- 80 (current-column)) ?-)))
#+END_SRC

I bind this function to an easy-to-remember key command.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c -") 'trs/insert-separator-line)
#+END_SRC

* Putting it all together

All of the code you've read above is written to a single file, =emacs.lp.el=.

#+BEGIN_SRC elisp :tangle emacs.lp.el :noweb yes :padline no
  ;;; emacs.lp.el --- Tom's Emacs customizations
  ;;
  ;; NOTE: This file is generated from emacs.org. You should not edit it directly.

  ;;; Custom functions

  <<custom-functions>>

  ;;; Emacs settings

  <<emacs-settings>>

  ;;; Mode-specific settings

  <<mode-specific-settings>>

  ;;; Org Mode

  <<org-mode-settings>>

  ;;; Key bindings

  <<key-bindings>>
#+END_SRC
