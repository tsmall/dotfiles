#+TITLE: Tom's Emacs Configuration
#+AUTHOR: Tom Small <tsmall3@gmail.com>

* Introduction

Welcome to my Emacs configuration file. This file contains a lot of changes
I've made over many years of using Emacs. It contains my own code and code
others have shared online. I've included credit for the authors of most of the
shared code, though I'm sure I've missed some. I'm sorry if I missed you. But
please let me know and I'll correct it!

This file is written in Babel for Org mode, in a literate programming style.
That way I can organize it for the reader and not the computer, using all of
the markup tools Org mode provides to describe the program right along with the
code itself.

* Organization of this document

This document is organized from the general to the specific.

First are the settings that apply to Emacs as a whole (see [[*Emacs settings][Emacs settings]]).
These are things like the size of the window at startup, the fonts to use,
and making the cursor not blink.

Then it focuses on settings that apply to specific modes (see [[*Mode-specific settings][Mode-specific
settings]]). This section has one sub-section per mode.

The next section describes some of the helper methods I've found and created
over time (see [[*Helpers and utilities][Helpers and utilities]]). These are little utilities to make
everyday text editing just a bit more pleasant.

Lastly, it combines all of the code together into a single file that we'll
configure Emacs to load at startup (see [[*Putting%20it%20all%20together][Putting it all together]]).

* Emacs settings
:PROPERTIES:
:noweb-ref: emacs-settings
:END:

This section defines the customizations that apply to Emacs as a whole.

** Sensible defaults

I disagree with many of Emacs's default settings. Who wants their cursor to
blink? That's just distracting. We don't need two spaces after a sentence.
That's just wasteful. Let's put things the way they should be.

#+BEGIN_SRC elisp
  (setq transient-mark-mode t)            ; Highlight regions
  (setq line-number-mode t)               ; Display line numbers
  (setq column-number-mode t)             ; Display column numbers
  (blink-cursor-mode 0)                   ; Don't blink the cursor
  (setq visible-bell nil)                 ; Disable beep
  (setq confirm-kill-emacs 'yes-or-no-p)  ; Confirm quit
  (tool-bar-mode -1)                      ; Disable tool bar
  (set-scroll-bar-mode nil)               ; Hide the scroll bars
  (fset 'yes-or-no-p 'y-or-n-p)           ; Make answering yes or no easier
  (setq-default fill-column 79)           ; Wrap at 79 columns by default
  (setq sentence-end-double-space nil)    ; Let one space end a sentence
#+END_SRC

** Fonts

I go back and forth with fonts all the time. It might be a problem. It's
pointless to say what I'm using now --- it will probably change soon. But here
are some of my favorite monospace fonts:

- [[https://github.com/tonsky/FiraCode][Fira Code]]
- [[https://blog.golang.org/go-fonts][Go and Go Mono]]
- [[https://ibm.github.io/type/][IBM Plex Mono]]
- [[http://input.fontbureau.com][Input]]
- [[https://be5invis.github.io/Iosevka/][Iosevka]]
- [[https://www.typography.com/fonts/operator/][Operator]]
- Roboto and Roboto Mono

#+BEGIN_SRC elisp
  (trs/set-default-font "Overpass Mono" 140)
  (trs/set-variable-font "Overpass" 140)
#+END_SRC

One of the cool things about Fira Code (and Iosevka) is that it has ligatures
for many character combinations commonly seen in code (like ->). But to have
them work in Emacs, I need to use the [[https://github.com/railwaycat/homebrew-emacsmacport][railwaycat Emacs port]] and enable this
setting:

#+BEGIN_SRC elisp
  (if (boundp 'mac-auto-operator-composition-mode)
      (mac-auto-operator-composition-mode))
#+END_SRC

** Tabs vs. spaces

Ahh, the age-old debate. Should you use spaces or tabs to indent your code? If
you use spaces, how many? Honestly, I'm a bit tired of this debate. I'll use
whatever a project has decided, or whatever the standard is for a language.
(This is also one of the reasons I really like Go and Lisps: there's one way to
format your code, and that's it.)

But it seems like, in general, four spaces has won. And that seems like a
reasonable default to me. So four spaces it is.

#+BEGIN_SRC elisp
  (setq-default tab-width 4)              ; Interpret tab char as 4 places
  (setq-default indent-tabs-mode nil)     ; Insert spaces instead of tabs
#+END_SRC

** Ido-mode

Ido-mode makes it much easier to switch buffers, open files, and to do many of
the things you do many times a day. It does that by showing all of your options
and letting you choose one with fewer keystrokes with fuzzy matching. It's
incredibly helpful.

#+BEGIN_SRC elisp
  (ido-mode t)                            ; Turn on ido-mode
  (setq ido-enable-flex-matching t)       ; Turn on flexible matching
  (setq-default Man-width fill-column)    ; Wrap man pages at fill-column
#+END_SRC

** "Uniquify" buffers

In some projects it's very likely that you'll end up with multiple files opened
with the exact same filename. In a Python project, for example, every package
has a =__init__.py= file. By default Emacs appends a number to the file's buffer
name to make it unique. But that doesn't really help you tell which is which.

Luckily there's a built-in package named =uniquify= that solves this problem! It
lets you choose alternative ways to differentiate buffers for identical
filenames. I've chosen to have it prepend a portion of the file's path.

#+BEGIN_SRC elisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Startup window size

I like to have Emacs start up with a slightly bigger window that it has by
default.

#+BEGIN_SRC elisp
  (add-to-list 'default-frame-alist '(height . 50))
  (add-to-list 'default-frame-alist '(width . 150))
#+END_SRC

** OS X settings

There are a few tweaks needed for Emacs to work as expected on OS X. The
biggest for me is a preference: using the Command key as the meta modifier. (I
also map the Caps Lock key to Control, but that's outside the scope of Emacs.)

The other big fix is about how the =$PATH= is set up. Programs launched from the
Finder don't have the bash =$PATH= settings applied. Luckily someone else has
already fixed that problem for us. We just have to call
~exec-path-from-shell-initialize~.

#+BEGIN_SRC elisp
  (when (eq system-type 'darwin)
    (setq mac-option-key-is-meta nil
          mac-command-key-is-meta t
          mac-command-modifier 'meta
          mac-option-modifier 'none)

    (exec-path-from-shell-initialize))
#+END_SRC

* Mode-specific settings
:PROPERTIES:
:noweb-ref: mode-specific-settings
:END:

The following subsections define mode-specific customizations.

** C mode

I don't work with C much, so I haven't felt the need to change much here. But
many other modes are based on =c-mode=, so setting the indentation offset there
applies to many of the other modes I /do/ use more often.

#+BEGIN_SRC elisp
  (setq c-basic-offset 4)
#+END_SRC

** Clojure / ClojureScript mode

*** Hoplon

These configs come from the [[https://github.com/hoplon/hoplon/wiki/For-Emacs-users][Hoplon Emacs configuration instructions]].

This adds support for hoplon files:

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.cljs\\.hl\\'" . clojurescript-mode))
#+END_SRC

While this properly indents hoplon macros:

#+BEGIN_SRC elisp
  (add-hook 'clojure-mode-hook
            '(lambda ()
               ;; Hoplon functions and macros
               (dolist (pair '((page . 'defun)
                               (loop-tpl . 'defun)
                               (if-tpl . '1)
                               (for-tpl . '1)
                               (case-tpl . '1)
                               (cond-tpl . 'defun)))
                 (put-clojure-indent (car pair)
                                     (car (last pair))))))
#+END_SRC

** HTML mode

The HTML mode is based on =sgml-mode=, which defines its own variable for
indentation. I'll use 4 spaces for indentation there.

#+BEGIN_SRC elisp
  (setq sgml-basic-offset 4)
#+END_SRC

* Org Mode
:PROPERTIES:
:noweb-ref: org-mode-settings
:END:

Org Mode is basically an application on its own. So rather than hiding it
inside the [[*Mode-specific%20settings][Mode-specific settings section]], I'm promoting these settings to
their own section.

** Initialization

Org Mode is designed to be modular. That way features that are only used by
some are not built in to the core. I've started to go outside the default
modules, so I need to turn those on when setting up Org Mode.

#+BEGIN_SRC elisp :noweb tangle
  (require 'org)
  <<org-modules>>
#+END_SRC

Automatically turn on Org Mode whenever opening a file with the =.org=
extension. Also turn on =olivetti-mode=, which I just find to be a more pleasant
writing environment for non-code files.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
  (add-hook 'org-mode-hook 'olivetti-mode)
#+END_SRC

** General behavior

Hide the emphasis markers to make the text more like a live preview.

#+BEGIN_SRC elisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

Don't start indented; I turn on that on for specific files when I want it.

#+BEGIN_SRC elisp
  (setq org-startup-indented nil)
#+END_SRC

Leave blank lines in between sections when they're folded. (I don't love having
them there always, but the default behavior is often confusing to me; I never
know where the blank lines are going to end up when moving things around.)

#+BEGIN_SRC elisp
  (setq org-cycle-separator-lines 1)
#+END_SRC

** Editing behavior

Don't split the line when the cursor is in the middle of it and I press
=M-Return=.

#+BEGIN_SRC elisp
  (setq org-M-RET-may-split-line nil)
#+END_SRC

Leave the content under a folded heading intact when inserting a new heading
via =M-Return=.

#+BEGIN_SRC elisp
  (setq org-insert-heading-respect-content t)
#+END_SRC

When working with a folded org file, it can be easy to accidentally clobber
some of the folded content. I'd rather be explicit about that, and have Org
Mode prevent me from doing it.

#+BEGIN_SRC elisp
  (setq org-catch-invisible-edits 'error)
#+END_SRC

** Faces

Tell Org Mode to enable custom fonts for headlines marked "done" so I can style
them in my themes.

#+BEGIN_SRC elisp
  (setq org-fontify-done-headline t)
#+END_SRC

** Todo settings

Mark the date and time I finish every task.

#+BEGIN_SRC elisp
  (setq org-log-done 'time)
#+END_SRC

Don't let me mark a todo item as done if it has children that aren't done.

#+BEGIN_SRC elisp
  (setq org-enforce-todo-dependencies t)
#+END_SRC

If I've set access keys for todo states (for example, =TODO(t)=), then make it
easy to use those shortcut keys whenever I set a todo state.

#+BEGIN_SRC elisp
  (setq org-use-fast-todo-selection t)
#+END_SRC

When switching between todo states with the /S-cursor/ (shift key plus the left
or right arrow keys), don't trigger any state change events. This makes it easy
to cycle between them quickly.

#+BEGIN_SRC elisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

** Default todo keywords

These are often overridden on a per-file basis, but set a useful set of default
todo keywords so I don't /have/ to set them for every file.

#+BEGIN_SRC elisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")))
#+END_SRC

** Capturing

By default, capture things to my inbox file.

#+BEGIN_SRC elisp
  (setq org-default-notes-file (concat org-directory "/inbox.org"))
#+END_SRC

Some templates go directly to my todo file though.

#+BEGIN_SRC elisp
  (defvar trs/org-todo-file
    (concat org-directory "/todo.org"))
#+END_SRC

I have a few different templates, defined below.

#+BEGIN_SRC elisp :noweb tangle
  (setq org-capture-templates
        '(
           <<org-capture-templates>>
         ))
#+END_SRC

Capture inbox notes to my inbox file.

#+BEGIN_SRC elisp :noweb-ref org-capture-templates
  ("i" "Inbox" entry (file org-default-notes-file)
   "* %?\n")
#+END_SRC

Sometimes I can jump past the inbox and create a one-off todo directly.

#+BEGIN_SRC elisp :noweb-ref org-capture-templates
  ("t" "Todo" entry (file+headline trs/org-todo-file "One-offs")
   "* TODO %?\n")
#+END_SRC

Make it easy to capture things I want to read. This template assumes the
thing's URL is on the clipboard, and automatically creates a link to it.

#+BEGIN_SRC elisp :noweb-ref org-capture-templates
  ("r" "Read Later" entry (file+headline trs/org-todo-file "Short Reads")
   "* TODO %? [[[%c][%^{linkdesc|site}]]]\n")
#+END_SRC

** Refiling

Target every todo item with the "PROJ" tag and every heading in the current file up to the 2nd level when refiling.

#+BEGIN_SRC elisp
  (setq org-refile-targets '((nil :todo . "PROJ")
                             (nil :maxlevel . 2)))
#+END_SRC

** Agenda

*** Files

Include all files in my =~/org= directory in my agenda.

#+BEGIN_SRC elisp
  (setq org-agenda-files '("~/org"))
#+END_SRC

*** Behavior

Show the agenda in the current window.

#+BEGIN_SRC elisp
  (setq org-agenda-window-setup 'current-window)
#+END_SRC

Don't use compact blocks; it's easier to scan when they have separators.

#+BEGIN_SRC elisp
  (setq org-agenda-compact-blocks nil)
#+END_SRC

If a task is blocked, don't show it in the agenda.

#+BEGIN_SRC elisp
  (setq org-agenda-dim-blocked-tasks 'invisible)
#+END_SRC

*** Views

Move the tags further to the right, to allow more space for the item text.

#+BEGIN_SRC elisp
  (setq org-agenda-tags-column -105)
#+END_SRC

#+BEGIN_SRC elisp
  (setq org-agenda-custom-commands
        `(("o" "Custom Overview"
           ((agenda ""
                    ((org-agenda-overriding-header "Today:")
                     (org-agenda-span 'day)))
            (tags-todo "+TODO=\"TODO\"+P1"
                       ((org-agenda-overriding-header "Flagged:")))
            (tags-todo "@errand"
                       ((org-agenda-overriding-header "Errands:")))
            (tags-todo "read|watch"
                  ((org-agenda-overriding-header "Content Queue:")))
            (todo "WAIT"
                  ((org-agenda-overriding-header "Waiting For:")))
            (tags-todo "+TODO=\"TODO\"-P1-@errand-read-watch"
                       ((org-agenda-overriding-header "Everything Else:")
                        (org-agenda-todo-ignore-scheduled 'all)))))))
#+END_SRC

** Habit tracking

I've started using Org Mode's /habit/ module to track some of my recurring tasks
that have looser recurring dates. One very nice feature of this module is that
it shows a little graph next to the item in the agenda that shows how well I've
done the habit.

To start, we need to turn on the module.

#+BEGIN_SRC elisp :noweb-ref org-modules
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
#+END_SRC

Move the habit graphs further to the right in my agenda views, to leave more space for the actual item's text.

#+BEGIN_SRC elisp
  (setq org-habit-graph-column 60)
#+END_SRC

* Helpers and utilities
:PROPERTIES:
:noweb-ref: custom-functions
:noweb-sep: "\n\n"
:END:

The following subsections define custom functions I've written to make my life
in Emacs just a little bit nicer. They are all in the "/trs/ namespace", meaning
I've prefixed them all with =trs/=.

** Increment number at point

This function is taken verbatim from [[http://www.emacswiki.org/emacs/IncrementNumber][the Emacs wiki]]. It increments the number
underneath the pointer. By default it increments the number by 1, but that can
be overriden in the standard Emacs way by pressing =C-u= followed by a number.

The biggest benefit of having this function is in macros. Often when you copy a
line with a number in it, you want that number incremented on the next line.
But you need to define your macro generically; if it changes the number to a
specific value then all the lines will have that new value. This function
solves that problem.

#+BEGIN_SRC elisp
  (defun trs/increment-number-decimal (&optional arg)
    "Increment the number forward from point by 'arg'."
    (interactive "p*")
    (save-excursion
      (save-match-data
        (let (inc-by field-width answer)
          (setq inc-by (if arg arg 1))
          (skip-chars-backward "0123456789")
          (when (re-search-forward "[0-9]+" nil t)
            (setq field-width (- (match-end 0) (match-beginning 0)))
            (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
            (when (< answer 0)
              (setq answer (+ (expt 10 field-width) answer)))
            (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                   answer)))))))
#+END_SRC

I bind this function to a simple keystroke to make using it even easier.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c i") 'trs/increment-number-decimal)
#+END_SRC

** Fonts and typography

I'm a bit nuts about fonts, and tend to change my preferred font quite often.
So I've made it easy for me to switch between them.

See [[*Fonts][Fonts]] to see where I'm using these functions.

#+BEGIN_SRC elisp
  (defun trs/set-default-font (family &optional height weight)
    "Set the default font."
    (dolist (font-name (list 'default 'fixed-pitch-serif))
      (set-face-attribute font-name nil
                          :family family
                          :height (or height 100)
                          :weight (or weight 'medium))))

  (defun trs/set-variable-font (family &optional height weight)
    "Set the variable width font."
    (set-face-attribute 'variable-pitch nil
                        :family family
                        :height (or height 100)
                        :weight (or weight 'medium)))
#+END_SRC

** Clear the buffer

I've found it very useful to be able to easily clear the current buffer. You
can do this by moving to the beginning, starting selection, moving to the end,
and cutting the text. But that's a lot of work for something I do often.
Instead, I've created my own function that does what I need for me.

#+BEGIN_SRC elisp
  (defun trs/clear-buffer ()
    "Clear the contents of the current buffer."
    (interactive)
    (delete-region 1 (point-max)))
#+END_SRC

I bind this function to an easy to type key combo that's become muscle memory
for me now.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c l") 'trs/clear-buffer)
#+END_SRC

** Copy full buffer

In addition to clearing the buffer, it's often useful to copy the entire text
of the buffer into the clipboard. Like with [[*Clear%20the%20buffer][clearing]], I could do this manually.
But this is easier.

#+BEGIN_SRC elisp
  (defun trs/copy-buffer-to-clipboard ()
    "Copy the entire contents of the current buffer to the clipboard."
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max))
    (message "Copied."))
#+END_SRC

I bind this to a key command to make using it easy.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c w") 'trs/copy-buffer-to-clipboard)
#+END_SRC

** Separator line

I find it useful to be able to break up long source code files into sections.
This is a kind of poor man's literate programming. I use a line of "-"
characters to indicate section breaks. The following function does all the work
of creating that text for me.

#+BEGIN_SRC elisp
  (defun trs/insert-separator-line ()
    "Insert '-' characters from point to column 80."
    (interactive)
    (insert (make-string (- 80 (current-column)) ?-)))
#+END_SRC

I bind this function to an easy-to-remember key command.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c -") 'trs/insert-separator-line)
#+END_SRC

* Putting it all together

All of the code you've read above is written to a single file, =emacs.lp.el=.

#+BEGIN_SRC elisp :tangle emacs.lp.el :noweb tangle :padline no
  ;;; emacs.lp.el --- Tom's Emacs customizations
  ;;
  ;; NOTE: This file is generated from emacs.org. You should not edit it directly.

  ;;; Custom functions

  <<custom-functions>>

  ;;; Emacs settings

  <<emacs-settings>>

  ;;; Mode-specific settings

  <<mode-specific-settings>>

  ;;; Org Mode

  <<org-mode-settings>>

  ;;; Key bindings

  <<key-bindings>>
#+END_SRC
