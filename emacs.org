#+TITLE: Tom's Emacs Configuration
#+AUTHOR: Tom Small <tsmall3@gmail.com>
#+STARTUP: overview

* Introduction

Welcome to my Emacs configuration file. This file contains a lot of changes
I've made over many years of using Emacs. It contains my own code and code
others have shared online. I've included credit for the authors of most of the
shared code, though I'm sure I've missed some. I'm sorry if I missed you. But
please let me know and I'll correct it!

* Organization of this document

This file is written in Babel for Org mode, in a literate programming style.
That way I can organize it for the reader and not the computer, using all of
the markup tools Org mode provides to describe the program right along with the
code itself.

This document is organized from the general to the specific. It's broken up
into many small sections, to make it easy to jump right to the section you're
interested. But it's also written to be read from beginning to end.

First are the settings that apply to Emacs as a whole (see [[*Emacs settings][Emacs settings]]).
These are things like the size of the window at startup, the fonts to use,
and making the cursor not blink.

Then it focuses on settings that apply to specific modes (see [[*Mode-specific settings][Mode-specific
settings]]). This section has one sub-section per mode.

The next section describes some of the helper methods I've found and created
over time (see [[*Helpers and utilities][Helpers and utilities]]). These are little utilities to make
everyday text editing just a bit more pleasant.

Lastly, it combines all of the code together into a single file that we'll
configure Emacs to load at startup (see [[*Putting%20it%20all%20together][Putting it all together]]).

* Emacs settings
:PROPERTIES:
:header-args: :noweb-ref emacs-settings
:END:

This section defines the customizations that apply to Emacs as a whole.

** Sensible defaults

I disagree with many of Emacs's default settings. Who wants their cursor to
blink? That's just distracting. We don't need two spaces after a sentence.
That's just wasteful. Let's put things the way they should be.

#+BEGIN_SRC elisp
  (setq transient-mark-mode t)            ; Highlight regions
  (setq line-number-mode t)               ; Display line numbers
  (setq column-number-mode t)             ; Display column numbers
  (blink-cursor-mode 0)                   ; Don't blink the cursor
  (setq visible-bell nil)                 ; Disable beep
  (setq confirm-kill-emacs 'yes-or-no-p)  ; Confirm quit
  (tool-bar-mode -1)                      ; Disable tool bar
  (set-scroll-bar-mode nil)               ; Hide the scroll bars
  (fset 'yes-or-no-p 'y-or-n-p)           ; Make answering yes or no easier
  (setq-default fill-column 79)           ; Wrap at 79 columns by default
  (setq sentence-end-double-space nil)    ; Let one space end a sentence
  (setq-default Man-width fill-column)    ; Wrap man pages at fill-column
#+END_SRC

** Frame title

I don't really like having the system name in the frame (window) title, but
otherwise the standard format is good.

#+begin_src elisp
  (setq frame-title-format '(multiple-frames "%b" ("" "%b - GNU Emacs")))
#+end_src

** Bell

By default, Emacs makes a noise when you do a lot of things. It happens /all the
time/ and kind of drives my nuts. So I turn that off.

#+begin_src elisp
  (setq ring-bell-function 'ignore)
#+end_src

** Fonts

One of my top interests is typography. So I end up switching which font I use
in my text editors and IDEs often. This is my latest combination:

#+BEGIN_SRC elisp
  (trs/set-default-font "JetBrains Mono NL" 130)
  (trs/set-comment-font "JetBrains Mono NL" 130)
  (trs/set-variable-font "Amazon Ember" 140)
#+END_SRC

Some of those fonts have ligatures for common coding character combinations
commonly (like ->). Stock Emacs doesn't have support for that, though. So to
have them work in Emacs, I need to use the [[https://github.com/railwaycat/homebrew-emacsmacport][railwaycat Emacs port]] and enable
this setting:

#+BEGIN_SRC elisp
  (if (boundp 'mac-auto-operator-composition-mode)
      (mac-auto-operator-composition-mode 0))
#+END_SRC

Here are characters that I want my fonts to render well:

#+begin_example
  ABCDEFGHIJKLMNOPQRSTUVWXYZ
  abcdefghijklmnopqrstuvwxyz
  0123456789 () [] <> {}
  ← → ✓ × ☐ ¼ ½ ¾ ⅓ ⅔ ∪ ∩ ∈
  0OI1l wwwv qpdb
  -> => --> ==> := ::
  == != === !== <= >= >>=
  ,* ** *** ****
  # ## ### ####
  - -- --- ----
#+end_example

** Tabs vs. spaces

Ahh, the age-old debate. Should you use spaces or tabs to indent your code? If
you use spaces, how many? Honestly, I'm a bit tired of this debate. I'll use
whatever a project has decided, or whatever the standard is for a language.
(This is also one of the reasons I really like Go and Lisps: there's one way to
format your code, and that's it.)

But it seems like, in general, four spaces has won. And that seems like a
reasonable default to me. So four spaces it is.

#+BEGIN_SRC elisp
  (setq-default tab-width 4)              ; Interpret tab char as 4 places
  (setq-default indent-tabs-mode nil)     ; Insert spaces instead of tabs
#+END_SRC

** Completion

fido-mode makes it much easier to switch buffers, open files, and to do many of
the things you do many times a day. It does that by showing all of your options
and letting you choose one with fewer keystrokes with fuzzy matching.

#+BEGIN_SRC elisp
  (fido-mode 1)
  (fido-vertical-mode 1)
#+END_SRC

** "Uniquify" buffers

In some projects it's very likely that you'll end up with multiple files opened
with the exact same filename. In a Python project, for example, every package
has a =__init__.py= file. By default Emacs appends a number to the file's buffer
name to make it unique. But that doesn't really help you tell which is which.

Luckily there's a built-in package named =uniquify= that solves this problem. It
lets you choose alternative ways to differentiate buffers for identical
filenames. I've chosen to have it prepend a portion of the file's path.

#+BEGIN_SRC elisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Startup window size

I like to have Emacs start up with a slightly bigger window that it has by
default.

#+BEGIN_SRC elisp
  (add-to-list 'default-frame-alist '(height . 35))
  (add-to-list 'default-frame-alist '(width . 115))
#+END_SRC

** OS X settings

There are a few tweaks needed for Emacs to work as expected on OS X. The
biggest for me is a preference: using the Command key as the meta modifier. (I
also map the Caps Lock key to Control, but that's outside the scope of Emacs.)

The other big fix is about how the =$PATH= is set up. Programs launched from the
Finder don't have the bash =$PATH= settings applied. Luckily someone else has
already fixed that problem for us. We just have to call
~exec-path-from-shell-initialize~.

#+BEGIN_SRC elisp
  (when (eq system-type 'darwin)
    (setq mac-option-key-is-meta t
          mac-command-key-is-meta t
          mac-command-modifier 'meta
          mac-option-modifier 'meta)

    (exec-path-from-shell-initialize))
#+END_SRC

** Window splitting

Emacs's default window splitting behavior often doesn't do what I want. It will
often split horizontally and open a new window instead of use the existing
vertical split. These settings effectively set the threshold for the heuristic
so high that Emacs will reuse my existing splits, making it more manual than
dynamic.

#+begin_src elisp
  (setq split-height-threshold 1200)
  (setq split-width-threshold 2000)
#+end_src

* Mode-specific settings
:PROPERTIES:
:header-args: :noweb-ref mode-specific-settings
:END:

The following subsections define mode-specific customizations.

** Ace Jump mode

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "M-C-j") 'ace-jump-mode)
#+END_SRC

** C mode

I don't work with C much, so I haven't felt the need to change much here. But
many other modes are based on =c-mode=, so setting the indentation offset there
applies to many of the other modes I /do/ use more often.

#+BEGIN_SRC elisp
  (setq c-basic-offset 4)
#+END_SRC

** Clojure / ClojureScript mode

*** Compojure

These indentation rules teach clojure-mode how to handle route code.
They're taken from the [[https://github.com/weavejester/compojure/wiki/Emacs-indentation][Compojure wiki]].

It requires using a macro defined in clojure-mode,
so first we have to require clojure-mode
to bring that macro into existence.

#+BEGIN_SRC elisp
  (require 'clojure-mode)
#+END_SRC

Then we can set up the indentation.

#+BEGIN_SRC elisp
  (define-clojure-indent
    (defroutes 'defun)
    (GET 2)
    (POST 2)
    (PUT 2)
    (DELETE 2)
    (HEAD 2)
    (ANY 2)
    (context 2))
#+END_SRC

*** Hoplon

These configs come from the [[https://github.com/hoplon/hoplon/wiki/For-Emacs-users][Hoplon Emacs configuration instructions]].

First, we need to teach Emacs that files ending with =.cljs.hl= are actually
ClojureScript files.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.cljs\\.hl\\'" . clojurescript-mode))
#+END_SRC

Then we need to teach it how to properly indent Hoplon's macros:

#+BEGIN_SRC elisp
  (add-hook 'clojure-mode-hook
            '(lambda ()
               ;; Hoplon functions and macros
               (dolist (pair '((page . 'defun)
                               (loop-tpl . 'defun)
                               (if-tpl . '1)
                               (for-tpl . '1)
                               (case-tpl . '1)
                               (cond-tpl . 'defun)))
                 (put-clojure-indent (car pair)
                                     (car (last pair))))))
#+END_SRC

** EditorConfig

Turn on EditorConfig support.

#+BEGIN_SRC elisp
  (editorconfig-mode 1)
#+END_SRC

** Expand Region

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-=") 'er/expand-region)
#+END_SRC

** Haskell

Turn on a few of haskell-mode's useful features:

#+BEGIN_SRC elisp
  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
  (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
#+END_SRC

** Highlight Symbol

Set up key bindings:

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key [f3]                 'highlight-symbol-next)
  (global-set-key [(shift f3)]         'highlight-symbol-prev)
  (global-set-key [(control f3)]       'highlight-symbol-at-point)
  (global-set-key [(control meta f3)]  'highlight-symbol-query-replace)
  (global-set-key [(control shift f3)] 'highlight-symbol-remove-all)
#+END_SRC

** HTML mode

The HTML mode is based on =sgml-mode=, which defines its own variable for
indentation. I'll use 4 spaces for indentation there.

#+BEGIN_SRC elisp
  (setq sgml-basic-offset 4)
#+END_SRC

** iedit

iedit complements multiple cursors by making it quick to select all instances
of a word in a buffer and edit them all at once.

#+begin_src elisp
  (use-package iedit
    :ensure t)
#+end_src

** iy-go-to-char

This mode teaches Emacs about a very efficient navigation feature
that I first enountered in Vim:
jumping to the next (or previous) occurance of a character.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c f") 'iy-go-to-char)
  (global-set-key (kbd "C-c F") 'iy-go-to-char-backward)
  (global-set-key (kbd "C-c ;") 'iy-go-to-char-continue)
  (global-set-key (kbd "C-c ,") 'iy-go-to-char-continue-backward)
#+END_SRC

** js2-mode

I like js2-mode more than the default JavaScript mode,
so we'll teach Emacs to always use it for =.js= files.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+END_SRC

Sometimes I like using the no-semicolon style,
and I don't want js2-mode to tell me my code is wrong
when I do that.

#+BEGIN_SRC elisp
  (setq js2-strict-missing-semi-warning nil)
  (setq js2-missing-semi-one-line-override nil)
  (setq js2-strict-trailing-comma-warning nil)
#+END_SRC

I also generally use two spaces to indent JavaScript code.

#+BEGIN_SRC elisp
  (setq js2-basic-offset 2)
#+END_SRC

** Magit (& Transients)

Magit extensively uses the Emacs Transient feature. The Transient system works
by defining a "level" for each transient command. By default that level is 4.
The maximum is 7. Every transient command that is at the default level or below
are available.

I want to have all options available by default. So I set my default to 7.

#+begin_src elisp
  (setq transient-default-level 7)
#+end_src

** Markdown mode

Markdown is all about writing, so I like to use Olivetti mode to format the
buffer cleanly, and automatically turn on spell checking (via =flyspell-mode=).

#+BEGIN_SRC elisp
  (add-hook 'markdown-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'olivetti-mode)
#+END_SRC

** Multiple Cursors

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-M->") 'mc/skip-to-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-M-<") 'mc/skip-to-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
  (global-set-key (kbd "C-c C->") 'mc/mark-all-like-this)

  (global-set-key (kbd "C-c C-r") 'mc/edit-lines)
  (global-set-key (kbd "M-<kp-enter>") 'set-rectangular-region-anchor)

  (global-set-key (kbd "M-C-<mouse-1>") 'mc/add-cursor-on-click)
#+END_SRC

** PHP mode

*** General configuration

This function sets up php-mode with a few other features that make editing PHP
code a little easier.

#+begin_src elisp
  (defun trs/setup-php-mode ()
    (interactive)
    (subword-mode +1))
#+end_src

I want these settings on for every PHP buffer, so I add it to the hook.

#+begin_src elisp
  (add-hook 'php-mode-hook #'trs/setup-php-mode)
#+end_src

*** Drupal file extensions

When working with Drupal code,
some PHP code is in files with different extensions.
So we need to teach Emacs about them.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.inc$" . php-mode))
  (add-to-list 'auto-mode-alist '("\\.install$" . php-mode))
  (add-to-list 'auto-mode-alist '("\\.module$" . php-mode))
#+END_SRC

*** PHP REPL

I find it very useful to be able to quickly open a PHP REPL to run experiments,
so I created this command to make that quick and easy in Emacs.

#+begin_src elisp
  (defun trs/php-repl ()
    (interactive)
    (let ((buffer (make-comint "php" "php" nil "-a")))
      (switch-to-buffer-other-window buffer)
      (setq comint-process-echoes t)))
#+end_src

** Projectile

Enable projectile-mode:

#+begin_src elisp
  (projectile-mode +1)
#+end_src

Bind Projectile to a convenient keyboard shortcut:

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (define-key projectile-mode-map (kbd "C-c t") 'projectile-command-map)
#+END_SRC

** Taskpaper mode

Taskpaper is a great outline format, especially for checklists. Emacs's
taskpaper-mode is a great implementation of it.

#+begin_src elisp
  (use-package taskpaper-mode
    :ensure t)
#+end_src

** TypeScript mode

I'm using a combination of the =typescript-mode= package (for syntax
highlighting) and =tide= (for type checking and other IDE features).

*** General TypeScript configuration

This function sets up typescript-mode with a few other features that make
editing TypeScript code a little easier.

#+begin_src elisp
  (defun trs/setup-typescript-mode ()
    (interactive)
    (subword-mode +1))
#+end_src

I want these settings on for every TypeScript buffer, so I add it to the hook.

#+begin_src elisp
  (add-hook 'typescript-mode-hook #'trs/setup-typescript-mode)
#+end_src

*** File extensions

Tell emacs that files that end in =.tsx= are also TypeScript files.

#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-mode))
#+end_src

*** TypeScript "compilation"

It's helpful to be able to kick off yarn tests, lints, and builds from right
inside Emacs. I can use the built-in =compile= function to do most of the work.
But it's convenient to have some wrappers around it.

#+begin_src elisp
  (defun yarn-lint ()
    (interactive)
    (compile "yarn lint"))

  (defun yarn-test ()
    (interactive)
    (compile "yarn test"))

  (defun yarn-build ()
    (interactive)
    (compile "yarn build"))
#+end_src

*** Tide configuration

This function sets up tide mode with all of the configurations I want:

#+begin_src elisp
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1))
#+end_src

Then this turns it on whenever I open a TypeScript file:

#+begin_src elisp
  (add-hook 'typescript-mode-hook #'setup-tide-mode)
#+end_src

** Web mode

Web mode is the best solution I've found so far for working with HTML files,
which can contain other languages embedded inside it (e.g. JS or CSS).

Teach Emacs to always use web-mode for =.html= files:

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
#+END_SRC

Then tweak web-mode's indentation settings to match the style I use.

#+BEGIN_SRC elisp
  (setq web-mode-markup-indent-offset 4
        web-mode-css-indent-offset 4
        web-mode-code-indent-offset 4
        web-mode-style-padding 4
        web-mode-script-padding 4
        web-mode-block-padding 4)
#+END_SRC

** yasnippet

#+BEGIN_SRC elisp
  (yas-global-mode 1)
#+END_SRC

** zap-to-char

By default, the zap-to-char package binds Meta-z to the =zap-to-char= function.
But I've found that I want to leave the character much more often than I want
to delete it. Luckily zap-to-char also provides the =zap-up-to-char= function.
I've rebound the normal Meta-z key binding to that function instead.

#+BEGIN_SRC elisp
  (global-set-key (kbd "M-z") 'zap-up-to-char)
#+END_SRC

* Org Mode
:PROPERTIES:
:header-args: :noweb-ref org-mode-settings
:END:

Org Mode is basically an application on its own. So rather than hiding it
inside the [[*Mode-specific%20settings][Mode-specific settings section]], I'm promoting these settings to
their own section.

** Initialization

Org Mode is designed to be modular. That way features that are only used by
some are not built in to the core. I've started to go outside the default
modules, so I need to turn those on when setting up Org Mode.

#+BEGIN_SRC elisp :noweb yes
  (require 'org)
  (require 'org-mouse)
  <<org-modules>>
#+END_SRC

Automatically turn on Org Mode whenever opening a file with the =.org=
extension.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
#+END_SRC

** General behavior

Hide the emphasis markers to make the text more like a live preview.

#+BEGIN_SRC elisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

Indent bullets to make the hierarchy easier to see.

#+BEGIN_SRC elisp
  (setq org-startup-indented t)
#+END_SRC

Leave blank lines in between sections when they're folded. (I don't love having
them there always, but the default behavior is often confusing to me; I never
know where the blank lines are going to end up when moving things around.)

#+BEGIN_SRC elisp
  (setq org-cycle-separator-lines 1)
#+END_SRC

** Editing behavior

Don't split the line when the cursor is in the middle of it and I press
=M-Return=.

#+BEGIN_SRC elisp
  (setq org-M-RET-may-split-line nil)
#+END_SRC

Leave the content under a folded heading intact when inserting a new heading
via =M-Return=.

#+BEGIN_SRC elisp
  (setq org-insert-heading-respect-content t)
#+END_SRC

When working with a folded org file, it can be easy to accidentally clobber
some of the folded content. I'd rather be explicit about that, and have Org
Mode prevent me from doing it.

#+BEGIN_SRC elisp
  (setq org-catch-invisible-edits 'error)
#+END_SRC

** Faces

Tell Org Mode to enable custom fonts for headlines marked "done" so I can style
them in my themes.

#+BEGIN_SRC elisp
  (setq org-fontify-done-headline t)
#+END_SRC

** Link abbreviations

Org Mode provides a very helpful shortcut: you can provide your own link
abbreviations, which will be expanded into the full link. I find this very
helpful for things like work tickets.

#+begin_src elisp
  (setq org-link-abbrev-alist
        '(("PE" . "https://powerschoolgroup.atlassian.net/browse/PE-")))
#+end_src

** Todo settings

Mark the date and time I finish every task.

#+BEGIN_SRC elisp
  (setq org-log-done nil)
#+END_SRC

Don't let me mark a todo item as done if it has children that aren't done.

#+BEGIN_SRC elisp
  (setq org-enforce-todo-dependencies t)
#+END_SRC

If I've set access keys for todo states (for example, =TODO(t)=), then make it
easy to use those shortcut keys whenever I set a todo state.

#+BEGIN_SRC elisp
  (setq org-use-fast-todo-selection t)
#+END_SRC

When switching between todo states with the /S-cursor/ (shift key plus the left
or right arrow keys), don't trigger any state change events. This makes it easy
to cycle between them quickly.

#+BEGIN_SRC elisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

Start warning me of upcoming deadlines 7 days in advance.

#+BEGIN_SRC elisp
  (setq org-deadline-warning-days 7)
#+END_SRC

Define a "stuck" project as one that is a "PROJ" todo item with no subtasks of
the "TODO" or "WAIT" types.

#+BEGIN_SRC elisp
  (setq org-stuck-projects '("TODO=\"PROJ\"" ("TODO" "WAIT") nil ""))
#+END_SRC

** Default todo keywords

These are often overridden on a per-file basis, but set a useful set of default
todo keywords so I don't /have/ to set them for every file.

#+BEGIN_SRC elisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "STRT(s)" "WAIT(w)" "|" "DONE(d)" "CNCL(c)")))
#+END_SRC

** Capturing

By default, capture things to my inbox file.

#+BEGIN_SRC elisp
  (setq org-default-notes-file (concat org-directory "/inbox.org"))
#+END_SRC

Some templates go directly to my todo file though.

#+BEGIN_SRC elisp
  (defvar trs/org-todo-file
    (concat org-directory "/todo.org"))
#+END_SRC

I have a few different templates, defined below.

#+BEGIN_SRC elisp :noweb yes
  (setq org-capture-templates
        '(
           <<org-capture-templates>>
         ))
#+END_SRC

Capture inbox notes to my inbox file.

#+BEGIN_SRC elisp :noweb-ref org-capture-templates
  ("i" "Inbox" entry (file org-default-notes-file)
   "* %?\n")
#+END_SRC

Sometimes I can jump past the inbox and create a one-off todo directly.

#+BEGIN_SRC elisp :noweb-ref org-capture-templates
  ("t" "Todo" entry (file+headline trs/org-todo-file "One-offs")
   "* TODO %?\n")
#+END_SRC

Make it easy to capture things I want to read. This template assumes the
thing's URL is on the clipboard, and automatically creates a link to it.

#+BEGIN_SRC elisp :noweb-ref org-capture-templates
  ("r" "Read Later" entry (file+headline trs/org-todo-file "Short Reads")
   "* TODO %? [[[%c][%^{linkdesc|site}]]]\n")
#+END_SRC

** Refiling

Target every todo item with the "PROJ" tag and every heading in the current file up to the 2nd level when refiling.

#+BEGIN_SRC elisp
  (setq org-refile-targets '((nil :todo . "PROJ")
                             (nil :maxlevel . 2)))
#+END_SRC

** Habit tracking

I've started using Org Mode's /habit/ module to track some of my recurring tasks
that have looser recurring dates. One very nice feature of this module is that
it shows a little graph next to the item in the agenda that shows how well I've
done the habit.

To start, we need to turn on the module.

#+BEGIN_SRC elisp :noweb-ref org-modules
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
#+END_SRC

Move the habit graphs further to the right in my agenda views, to leave more space for the actual item's text.

#+BEGIN_SRC elisp
  (setq org-habit-graph-column 65)
#+END_SRC

** Org Babel

#+begin_src elisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (shell . t)))
#+end_src

** Presenting in Org Mode

I find Org Mode files to be a great way to present information, especially to
technical audiences. These are some enhancements I found that make presenting
in Org Mode even better.

#+begin_src elisp
  (load "org-present")
#+end_src

** Agenda

*** Behavior

Show the agenda in the current window.

#+BEGIN_SRC elisp
  (setq org-agenda-window-setup 'current-window)
#+END_SRC

Don't use compact blocks; it's easier to scan when they have separators.

#+BEGIN_SRC elisp
  (setq org-agenda-compact-blocks nil)
#+END_SRC

If a task is blocked, don't show it in the agenda.

#+BEGIN_SRC elisp
  (setq org-agenda-dim-blocked-tasks 'invisible)
#+END_SRC

Don't show any tasks that are scheduled for the future in any of my todo lists.

#+BEGIN_SRC elisp
  (setq org-agenda-todo-ignore-scheduled 'future)
  (setq org-agenda-tags-todo-honor-ignore-options t)
#+END_SRC

Move the tags further to the right, to allow more space for the item text.

#+BEGIN_SRC elisp
  (setq org-agenda-tags-column 'auto)
#+END_SRC

*** Views

The custom agenda commands defined below will be all combined here to define
the =org-agenda-custom-commands= variable.

#+BEGIN_SRC elisp :noweb yes
  <<org-agenda-view-functions>>
  (setq org-agenda-custom-commands
        `(("o" "Overview" ,@(trs/org-agenda-views/overview))
          ("w" "Work" ,@(trs/org-agenda-views/work))
          ("h" "Home" ,@(trs/org-agenda-views/home))
          ("f" "Flagged Projects" ,@(trs/org-agenda-views/flagged-projects))))
#+END_SRC

**** Helper Functions

This function tells Org mode to skip a todo if it is scheduled for some time in the future. (After all, that's why I scheduled it: I don't want to think about it until then.)

#+BEGIN_SRC elisp
  (defun trs/org-agenda-skip-if-scheduled-for-later ()
    "If this function returns nil, the current match should not be skipped.
  Otherwise, the function must return a position from where the search
  should be continued."
    (ignore-errors
      (let ((subtree-end (save-excursion (org-end-of-subtree t)))
            (scheduled-seconds (time-to-seconds
                                (org-time-string-to-time
                                 (org-entry-get nil "SCHEDULED"))))
            (now (time-to-seconds (current-time))))
        (and scheduled-seconds
             (>= scheduled-seconds now)
             subtree-end))))
#+END_SRC

**** Overview

My most important view is my "overview". It's my command center. It is intended
to give me all the information I need to make a decision about what to do next.

#+BEGIN_SRC elisp :noweb-ref org-agenda-view-functions
  (defun trs/org-agenda-views/overview ()
    '(((agenda ""
               ((org-agenda-overriding-header "Today:")
                (org-agenda-span 'day)
                (org-agenda-skip-deadline-if-done t)
                (org-agenda-skip-scheduled-if-done t)))
       (tags-todo "+TODO=\"STRT\""
                  ((org-agenda-overriding-header "Started:")))
       (tags-todo "@errand"
                  ((org-agenda-overriding-header "Errands:")))
       (tags-todo "+TODO=\"TODO\"-@errand-read-watch"
                  ((org-agenda-overriding-header "Tasks:")))
       (todo "WAIT"
             ((org-agenda-overriding-header "Waiting For:")))
       (tags-todo "read|watch"
                  ((org-agenda-overriding-header "Content Queue:"))))

      ;; These settings apply to all of the above.
      ((org-agenda-skip-scheduled-if-deadline-is-shown t)
       (org-agenda-todo-ignore-scheduled t))))
#+END_SRC

**** Work View

This is a version of my [[* Overview][Overview]] that is tailored to only show me the things I
need to see while I'm at work.

#+BEGIN_SRC elisp :noweb-ref org-agenda-view-functions
  (defun trs/org-agenda-views/work ()
    '(((agenda ""
               ((org-agenda-overriding-header "Today:")
                (org-agenda-span 'day)
                (org-agenda-skip-deadline-if-done t)
                (org-agenda-skip-scheduled-if-done t)))
       (tags-todo "+TODO=\"STRT\""
                  ((org-agenda-overriding-header "Started:")))
       (tags-todo "@errand"
                  ((org-agenda-overriding-header "Errands:")))
       (tags-todo "@workday"
                  ((org-agenda-overriding-header "Workday Tasks:")))
       (tags-todo "+TODO=\"TODO\"-@errand-@workday-@home-read-watch"
                  ((org-agenda-overriding-header "Tasks:")))
       (todo "WAIT"
             ((org-agenda-overriding-header "Waiting For:")))
       (tags-todo "read|watch"
                  ((org-agenda-overriding-header "Content Queue:"))))

      ;; These settings apply to all of the above.
      ((org-agenda-skip-scheduled-if-deadline-is-shown t)
       (org-agenda-todo-ignore-scheduled t))))
#+END_SRC

**** Home View

This is a version of my [[* Overview][Overview]] that is tailored to only show me the things I
need to see while I'm at home.

#+BEGIN_SRC elisp :noweb-ref org-agenda-view-functions
  (defun trs/org-agenda-views/home ()
    '(((agenda ""
               ((org-agenda-overriding-header "Today:")
                (org-agenda-span 'day)
                (org-agenda-skip-deadline-if-done t)
                (org-agenda-skip-scheduled-if-done t)))
       (tags-todo "+TODO=\"STRT\""
                  ((org-agenda-overriding-header "Started:")))
       (tags-todo "@errand"
                  ((org-agenda-overriding-header "Errands:")))
       (tags-todo "@home"
                  ((org-agenda-overriding-header "Only At Home:")))
       (tags-todo "+TODO=\"TODO\"-@errand-@workday-@home-read-watch"
                  ((org-agenda-overriding-header "Tasks:")))
       (todo "WAIT"
             ((org-agenda-overriding-header "Waiting For:")))
       (tags-todo "read|watch"
                  ((org-agenda-overriding-header "Content Queue:"))))

      ;; These settings apply to all of the above.
      ((org-agenda-skip-scheduled-if-deadline-is-shown t)
       (org-agenda-todo-ignore-scheduled t))))
#+END_SRC

**** Flagged Projects

Since these projects should be "blocked" -- they should all have TODO items
inside them -- I temporarily override the setting that would otherwise hide
them in agenda views.

#+BEGIN_SRC elisp :noweb-ref org-agenda-view-functions
  (defun trs/org-agenda-views/flagged-projects ()
    '(tags-todo
      "P1+TODO=\"PROJ\""
      ((org-agenda-dim-blocked-tasks nil))))
#+END_SRC

** Verb

#+begin_src elisp
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-c C-r") verb-command-map))
#+end_src

** Column Properties

#+begin_src elisp
  (set-face-attribute 'org-column nil :inherit 'default)
  (set-face-attribute 'org-column-title nil :inherit 'default)
#+end_src

* Viewing non-text files
:PROPERTIES:
:header-args: :noweb-ref non-text-viewing
:END:

** EPUBs

The =nov= package makes Emacs a great epub reader.

#+begin_src elisp
  (use-package nov
    :ensure t
    :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+end_src

** Images

By default, Emacs can't view webp images. But this simple setting
fixes that.

#+begin_src elisp
  (setq image-use-external-converter t)
#+end_src

** PDFs
The =pdf-tools= package improves the way Emacs renders PDFs, making it a great
viewer. I've now started using it more often than Firefox to read PDFs. It's
especially great with the =org-pdftools= package that lets you add links to
specific pages in PDFs.

#+begin_src elisp
  (use-package pdf-tools
    :ensure t
    :init
    (pdf-loader-install))

  (use-package org-pdftools
    :ensure t
    :hook (org-mode . org-pdftools-setup-link))
#+end_src

* RSS feeds
:PROPERTIES:
:header-args: :noweb-ref elfeed-settings
:END:

I use elfeed to read my RSS and Atom feeds. Here are the RSS feeds that I
subscribe to.

** Family and friends

These are feeds of things my family and friends do online. (Sadly Facebook and
Twitter are where most of that stuff ends up now, and they don't play well with
the open web. So this is a pretty anemic list.)

#+begin_src elisp
  (setq elfeed-feeds/family
        (cl-map 'list (lambda (url) (list url 'family))
                '("https://medium.com/feed/@sarahmiller_22747"
                  "http://mselroy.blogspot.com/feeds/posts/default?alt=rss"
                  "https://www.nestingdollkay.com/blog?format=RSS")))
#+end_src

** News

While I find it distracting and unhelpful to read the news too often, I do try
to keep informed. And I like to try to get a view on what people on many
different sides of an issue say.

*** Local news

#+begin_src elisp
  (setq elfeed-feeds/news-local
        (cl-map 'list (lambda (url) (list url 'news 'local))
                '("https://theotherhudsonvalley.com/feed/"
                  "https://therivernewsroom.com/feed/")))
#+end_src

*** National news

#+begin_src elisp
  (setq elfeed-feeds/news-national
        (cl-map 'list (lambda (url) (list url 'news 'national))
                '("http://newsrss.bbc.co.uk/rss/newsonline_world_edition/front_page/rss.xml"
                  "https://feeds.npr.org/1001/rss.xml"
                  "http://www.nytimes.com/services/xml/rss/nyt/HomePage.xml")))
#+end_src

** Random stuff

These are things I enjoy, that don't really fit into any of the other
categories.

#+begin_src elisp
  (setq elfeed-feeds/random
        (cl-map 'list (lambda (url) (list url 'random))
                '("http://feeds.kottke.org/main"
                  "http://www.justinobeirne.com/rss?format=rss"
                  "https://noeldemartin.com/blog/rss.xml"
                  "https://onefoottsunami.com/feed/json/")))
#+end_src

** Tech news

I split these up into a few groups.

*** Fast feeds

The "fast" ones are feeds that are updated often and produce a lot of data:

#+begin_src elisp
  (setq elfeed-feeds/tech-fast
        (cl-map 'list (lambda (url) (list url 'tech 'fast))
                '("http://om.co/feed/"
                  "https://daringfireball.net/feeds/main"
                  "http://www.techspot.com/backend.xml"
                  "http://rss.slashdot.org/Slashdot/slashdot"
                  "https://sixcolors.com/feed.json"
                  "https://inessential.com/feed.json"
                  "https://cate.blog/feed/"
                  "http://www.loopinsight.com/feed/"
                  "http://beckyhansmeyer.com/feed/"
                  "https://hnrss.org/frontpage"
                  "https://shopify.engineering/blog.atom"
                  "https://www.eff.org/rss/updates.xml")))
#+end_src

*** Slow feeds

The "slow" ones are updated far less frequently. They're more likely to be
things I don't want to miss, so being able to see only them saves me a lot of
time scanning.

#+begin_src elisp
  (setq elfeed-feeds/tech-slow
        (cl-map 'list (lambda (url) (list url 'tech 'slow))
                '("http://adactio.com/articles/rss"
                  "http://adactio.com/journal/rss"
                  "http://blog.couchdb.org/feed/"
                  "http://blog.golang.org/feeds/posts/default"
                  "http://blogs.perl.org/users/damian_conway/atom.xml"
                  "http://blogs.perl.org/users/psc/atom.xml"
                  "http://ericasadun.com/feed/"
                  "http://hypercritical.co/feeds/main"
                  "http://jvns.ca/atom.xml"
                  "http://leahneukirchen.org/trivium/index.atom"
                  "http://redecentralize.org/blog/feed.rss"
                  "http://staltz.com/feed.xml"
                  "http://tonsky.me/blog/atom.xml"
                  "http://www.omnigroup.com/blog/rss/"
                  "https://blog.elementary.io/feed.xml"
                  "https://blog.ploeh.dk/rss.xml"
                  "https://blog.standardnotes.org/rss/"
                  "https://blog.workflowy.com/feed/"
                  "https://brave.com/feed/"
                  "https://clojure.org/feed.xml"
                  "https://cognitect.com/feed.xml"
                  "https://devblogs.microsoft.com/sustainable-software/feed/"
                  "https://drewdevault.com/blog/index.xml"
                  "https://go.dev/blog/feed.atom"
                  "https://harelang.org/blog/index.xml"
                  "https://lexi-lambda.github.io/feeds/all.rss.xml"
                  "https://listed.to/@Listed/feed"
                  "https://medium.com/feed/@steve-yegge"
                  "https://medium.com/feed/darklang"
                  "https://protesilaos.com/codelog.xml"
                  "https://randsinrepose.com/feed/"
                  "https://whispersystems.org/blog/rss.xml"
                  "https://www.discoverdev.io/rss.xml"
                  "https://www.gingerbill.org/article/index.xml"
                  "https://www.pine64.org/feed/"
                  "https://ziglang.org/news/index.xml")))
#+end_src

*** Work

These are feeds that I subscribe to that are directly relevant to my current
job. There's definitely some overlap with the "slow" category, but I find it
useful to be able to filter to just these.

#+begin_src elisp
  (setq elfeed-feeds/tech-work
        (cl-map 'list (lambda (url) (list url 'tech 'slow 'work))
                '("https://alistapart.com/main/feed/"
                  "https://android-developers.googleblog.com/feeds/posts/default"
                  "https://aws.amazon.com/blogs/aws/feed/"
                  "https://blog.chromium.org/feeds/posts/default"
                  "https://blog.jetbrains.com/kotlin/feed/"
                  "https://devblogs.microsoft.com/typescript/feed/"
                  "https://hacks.mozilla.org/feed/"
                  "https://swift.org/atom.xml"
                  "https://www.php.net/feed.atom"
                  "https://web.dev/feed.xml"
                  "https://webkit.org/feed/")))
#+end_src

*** Advent calendars

I also have a few "advent calendar" blogs that I like to follow:

#+begin_src elisp
  (setq elfeed-feeds/tech-advent
        (cl-map 'list (lambda (url) (list url 'tech 'advent))
                '("https://rakuadventcalendar.wordpress.com/feed/"
                  "http://feeds.feedburner.com/24ways?format=xml"
                  "http://www.perladvent.org/2020/atom.xml")))
#+end_src

** EdTech

These are feeds I follow to keep up with what's going on in the world of
education and education technology.

#+begin_src elisp
  (setq elfeed-feeds/edtech
        (cl-map 'list (lambda (url) (list url 'edtech))
                '("https://www.edsurge.com/articles_rss"
                  "http://feeds.feedburner.com/EdTechK12"
                  "https://www.highereddive.com/feeds/news/"
                  "http://feeds.feedburner.com/edweek/marketbrief"
                  "https://www.powerschool.com/feed/")))
#+end_src

** Podcasts

These are the podcasts I like to listen to.

#+begin_src elisp
  (setq elfeed-feeds/podcasts
        (cl-map 'list (lambda (url) (list url 'podcast))
                '("http://feed.songexploder.net/SongExploder"
                  "http://feed.thisamericanlife.org/talpodcast"
                  "http://feeds.feedburner.com/cognicast"
                  "http://feeds.megaphone.fm/20k"
                  "http://feeds.wnyc.org/radiolab"
                  "http://www.wnycstudios.org/feeds/shows/deathsexmoney"
                  "http://www.wnycstudios.org/feeds/shows/experiment"
                  "https://changelog.com/podcast/feed"
                  "https://corecursive.com/feed"
                  "https://feeds.buzzsprout.com/1411126.rss"
                  "https://feeds.eff.org/howtofixtheinternet"
                  "https://feeds.megaphone.fm/decoderring"
                  "https://feeds.npr.org/344098539/podcast.xml"
                  "https://feeds.npr.org/510307/podcast.xml"
                  "https://feeds.npr.org/510312/podcast.xml"
                  "https://feeds.simplecast.com/BqbsxVfO"
                  "https://feeds.simplecast.com/L9810DOa"
                  "https://feeds.simplecast.com/_EGvSe3D"
                  "https://feeds.simplecast.com/kwWc0lhf"
                  "https://feeds.simplecast.com/rZ0cYk12"
                  "https://feeds.transistor.fm/thoughts-on-functional-programming-podcast-by-eric-normand"
                  "https://files.manager-tools.com/files/public/feeds/career_tools_podcasts.xml"
                  "https://files.manager-tools.com/files/public/feeds/manager-tools-podcasts.xml"
                  "https://handmade.network/podcast/podcast.xml"
                  "https://omny.fm/shows/the-take/playlists/podcast.rss"
                  "https://radioopensource.org/feed/"
                  "https://rss.art19.com/call-me-curious"
                  "https://rss.wbur.org/endlessthread/podcast"
                  "https://seradio.libsyn.com/rss"
                  "https://www.omnycontent.com/d/playlist/3aeeb75f-3358-42d4-8232-acad017ea3bd/dac5a742-0a1b-4f4b-b917-acb7015564f7/e7e10a67-651c-4ddf-9c47-acb70155651d/podcast.rss"
                  "https://www.omnycontent.com/d/playlist/e73c998e-6e60-432f-8610-ae210140c5b1/cfb428ef-eafc-44d0-9d09-ae2701747e6f/fb626e1f-112c-4246-a40d-ae2701747e7d/podcast.rss"
                  "https://www.qdnow.com/grammar.xml")))

#+end_src

** Putting it all together

#+begin_src elisp
  (setq elfeed-feeds
        (append
         elfeed-feeds/family
         elfeed-feeds/news-local
         elfeed-feeds/news-national
         elfeed-feeds/podcasts
         elfeed-feeds/random
         elfeed-feeds/tech-advent
         elfeed-feeds/tech-fast
         elfeed-feeds/tech-slow
         elfeed-feeds/tech-work
         elfeed-feeds/edtech))
#+end_src

* Playing music with Bongo
:PROPERTIES:
:header-args: :noweb-ref bongo-settings
:END:

#+begin_src elisp
  (require 'bongo)

  (setq bongo-display-inline-playback-progress t)
  (setq bongo-mark-played-tracks t)

  (set-face-attribute 'bongo-elapsed-track-part nil
                      :background "pale goldenrod"
                      :strike-through nil)
#+end_src

* Managing podcasts with Elfeed and Bongo
:PROPERTIES:
:header-args: :noweb-ref elfeed-bongo
:END:

I'm trying out using Emacs--specifically Elfeed and Bongo--to manage my
podcasts. Credit goes to Protesilaos Stavrou (Prot) for the code that makes
this integration possible. See =prot-elfeed-bongo.el= for that code, which I have
made a few tweaks to to get everything working.

#+begin_src elisp
  (with-eval-after-load 'elfeed
    (load "~/.emacs.d/site-lisp/prot-elfeed-bongo.el")
    (let ((map elfeed-search-mode-map))
      (define-key map (kbd "Q") #'prot-elfeed-bongo-insert-item))
    (let ((map elfeed-show-mode-map))
      (define-key map (kbd "Q") #'prot-elfeed-bongo-insert-item)))
#+end_src

* Databases
:PROPERTIES:
:header-args: :noweb-ref databases
:END:

** SQL databases

Emacs has built-in support for connecting to SQL databases and working with
them in a REPL-like manner with its =sql-mode=. See that mode's documentation to
set up your database connections (look for =sql-connection-alist=).

** Encrypted passwords

What Emacs /doesn't/ have built-in is a way to store encrypted passwords.
Luckily, Emacs being Emacs, it provides all the tools you need; you just need
to put them together.

*** Create encrypted passwords file

First, you need to create a file =passwords.el.gpg= somewhere in your load path.
(That's probably going to be in the =emacs.d/site-lisp= directory.) That file
needs to set a variable named =trs/db-passwords=, which is an alist of connection
prefix to password. Here's an example:

#+begin_example
  (setq trs/db-passwords
        '((staging . "StagingPassword")
          (prod    . "ProdPassword")))
#+end_example

It also needs to /provide/ the ='passwords= feature:

#+begin_example
  (provide 'passwords)
#+end_example

By ending the file name with =.gpg=, emacs will automatically use GnuPG to
symmetrically encrypt the file whenever it opens or saves it. So you need to
have GnuPG installed and available in your path. (See troubleshooting tips
below if you hit any snags.)

*** Custom connection function

Now we need to teach Emacs how to use those passwords when connecting to the
database. The default =sql-connect= command doesn't know they exist. So I created
my own function that wraps that, adding the password logic.

First is this function that finds the correct password for the requested DB
connection, based on the connection name's prefix.

#+begin_src elisp
  (defun trs/get-db-password (connection-name)
    (let* ((name   (symbol-name connection-name))
           (parts  (split-string name "-"))
           (prefix (first parts))
           (key    (intern prefix)))
      (alist-get key trs/db-passwords)))
#+end_src

Then this function defines a new command, =trs/sql-connect=, which I use to
connect instead of the default =sql-connect= command. (This function is based on
the one shared by Tran Truang [[https://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client][on his blog]].)

#+begin_src elisp
  (require 'sql)

  (defun trs/sql-connect (connection-name)
    ;; Get parameters from the user interactively.
    (interactive
     (if sql-connection-alist
         (list (intern (sql-read-connection "Connection: ")))
       (user-error "No SQL Connections defined")))

    ;; Add the password to the connection info.
    (require 'passwords "passwords.el.gpg")
    (let ((connection-info (assoc connection-name sql-connection-alist))
          (password        (trs/get-db-password connection-name)))
      (delete sql-password connection-info)
      (nconc connection-info `((sql-password ,password)))
      (setq sql-connection-alist (assq-delete-all connection-name sql-connection-alist))
      (add-to-list 'sql-connection-alist connection-info))

    ;; Connect to the database.
    (sql-connect connection-name))
#+end_src

*** Troubleshooting

If you see this error when trying to encrypt the =passwords.el.gpg= file:

#+begin_example
  gpg-agent forwarding: inappropriate ioctl for device
#+end_example

Then follow these steps (from [[https://stackoverflow.com/a/59170001][this StackOverflow answer]]).

Add these lines to =~/.gnupg/gpg.conf=, creating it if it doesn't exist:

#+begin_example
  use-agent
  pinentry-mode loopback
#+end_example

Add this to =~/.gnupg/gpg-agent.conf=, creating it if it doesn't exist:

#+begin_example
  allow-loopback-pinentry
#+end_example

Then restart the agent by running:

#+begin_example
  echo RELOADAGENT | gpg-connect-agent
#+end_example

* Helpers and utilities
:PROPERTIES:
:header-args: :noweb-ref custom-functions
:noweb-sep: "\n\n"
:END:

The following subsections define custom functions I've written to make my life
in Emacs just a little bit nicer. They are all in the "/trs/ namespace", meaning
I've prefixed them all with =trs/=.

** Increment number at point

This function is taken verbatim from [[http://www.emacswiki.org/emacs/IncrementNumber][the Emacs wiki]]. It increments the number
underneath the pointer. By default it increments the number by 1, but that can
be overriden in the standard Emacs way by pressing =C-u= followed by a number.

The biggest benefit of having this function is in macros. Often when you copy a
line with a number in it, you want that number incremented on the next line.
But you need to define your macro generically; if it changes the number to a
specific value then all the lines will have that new value. This function
solves that problem.

#+BEGIN_SRC elisp
  (defun trs/increment-number-decimal (&optional arg)
    "Increment the number forward from point by 'arg'."
    (interactive "p*")
    (save-excursion
      (save-match-data
        (let (inc-by field-width answer)
          (setq inc-by (if arg arg 1))
          (skip-chars-backward "0123456789")
          (when (re-search-forward "[0-9]+" nil t)
            (setq field-width (- (match-end 0) (match-beginning 0)))
            (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
            (when (< answer 0)
              (setq answer (+ (expt 10 field-width) answer)))
            (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                   answer)))))))
#+END_SRC

I bind this function to a simple keystroke to make using it even easier.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c i") 'trs/increment-number-decimal)
#+END_SRC

** Fonts and typography

I'm a bit nuts about fonts, and tend to change my preferred font quite often.
So I've made it easy for me to switch between them.

See [[*Fonts][Fonts]] to see where I'm using these functions.

#+BEGIN_SRC elisp
  (defun trs/set-default-font (family &optional height weight)
    "Set the default font."
    (dolist (face (list 'default 'fixed-pitch-serif))
      (set-face-attribute face nil
                          :family family
                          :height (or height 100)
                          :weight (or weight 'normal))))

  (defun trs/set-comment-font (family &optional height weight)
    "Set the comment font."
    (dolist (face (list 'font-lock-comment-face 'font-lock-doc-face))
      (set-face-attribute face nil
                          :family family
                          :height (or height 100)
                          :weight (or weight 'normal))))

  (defun trs/set-variable-font (family &optional height weight)
    "Set the variable width font."
    (set-face-attribute 'variable-pitch nil
                        :family family
                        :height (or height 100)
                        :weight (or weight 'normal)))
#+END_SRC

** Clear the buffer

I've found it very useful to be able to easily clear the current buffer. You
can do this by moving to the beginning, starting selection, moving to the end,
and cutting the text. But that's a lot of work for something I do often.
Instead, I've created my own function that does what I need for me.

#+BEGIN_SRC elisp
  (defun trs/clear-buffer ()
    "Clear the contents of the current buffer."
    (interactive)
    (delete-region 1 (point-max)))
#+END_SRC

I bind this function to an easy to type key combo that's become muscle memory
for me now.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c l") 'trs/clear-buffer)
#+END_SRC

** Copy full buffer

In addition to clearing the buffer, it's often useful to copy the entire text
of the buffer into the clipboard. Like with [[*Clear%20the%20buffer][clearing]], I could do this manually.
But this is easier.

#+BEGIN_SRC elisp
  (defun trs/copy-buffer-to-clipboard ()
    "Copy the entire contents of the current buffer to the clipboard."
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max))
    (message "Copied."))
#+END_SRC

I bind this to a key command to make using it easy.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c w") 'trs/copy-buffer-to-clipboard)
#+END_SRC

** Separator line

I find it useful to be able to break up long source code files into sections.
This is a kind of poor man's literate programming. I use a line of "-"
characters to indicate section breaks. The following function does all the work
of creating that text for me.

#+BEGIN_SRC elisp
  (defun trs/insert-separator-line ()
    "Insert '-' characters from point to column 80."
    (interactive)
    (insert (make-string (- 80 (current-column)) ?-)))
#+END_SRC

I bind this function to an easy-to-remember key command.

#+BEGIN_SRC elisp :noweb-ref key-bindings
  (global-set-key (kbd "C-c -") 'trs/insert-separator-line)
#+END_SRC

** Epoch date to string

This function converts the number under point from Unix epoch format to a
human-readable format.

#+BEGIN_SRC elisp
  (defun trs/epoch-to-string ()
    "Convert a timestamp in the Unix epoch format to a human-readable string."
    (interactive)
    (let* ((epoch (string-to-number (current-word)))
           (format-string "%a %D %T")
           (time (seconds-to-time epoch))
           (formatted-time (format-time-string format-string time)))
      (kill-new formatted-time)
      (message formatted-time)))
#+END_SRC

** Open JIRA ticket

This function opens the JIRA ticket under point in the system's default
web browser.

#+BEGIN_SRC elisp
  (defun trs/jira-open ()
    "Open JIRA ticket under point in default web browser."
    (interactive)
    (let* ((ticket (current-word))
           (url (concat "https://powerschoolgroup.atlassian.net/browse/" ticket)))
      (browse-url url)))
#+END_SRC

** Save and restore windows

This code is courtesy of Erick Navarro, from his blog post [[https://erick.navarro.io/blog/save-and-restore-window-configuration-in-emacs/][Save and Restore
Window Configuration in Emacs]].

#+BEGIN_SRC elisp
  (defvar trs/window-snapshots '())

  (defun trs/save-window-snapshot ()
    "Save the current window configuration into `trs/window-snapshots` alist."
    (interactive)
    (let ((key (read-string "Enter a name for the snapshot: ")))
      (setf (alist-get key trs/window-snapshots) (current-window-configuration))
      (message "%s window snapshot saved!" key)))

  (defun trs/get-window-snapshot (key)
    "Given a KEY return the saved value in `trs/window-snapshots` alist."
    (let ((value (assoc key trs/window-snapshots)))
      (cdr value)))

  (defun trs/restore-window-snapshot ()
    "Restore a window snapshot from the trs/window-snapshots alist."
    (interactive)
    (let* ((snapshot-name (completing-read "Choose snapshot: " (mapcar #'car trs/window-snapshots)))
           (snapshot (trs/get-window-snapshot snapshot-name)))
      (if snapshot
          (set-window-configuration snapshot)
        (message "Snapshot %s not found" snapshot-name))))
#+END_SRC

* Putting it all together

All of the code you've read above is written to a single file, =emacs.lp.el=.

#+BEGIN_SRC elisp :tangle emacs.lp.el :noweb yes :padline no
  ;;; emacs.lp.el --- Tom's Emacs customizations
  ;;
  ;; NOTE: This file is generated from emacs.org. You should not edit it directly.

  ;;; Custom functions

  <<custom-functions>>

  ;;; Emacs settings

  <<emacs-settings>>

  ;;; Mode-specific settings

  <<mode-specific-settings>>

  ;;; Org Mode

  <<org-mode-settings>>

  ;;; PDF Viewing

  <<non-text-viewing>>

  ;;; Databases

  <<databases>>

  ;;; Key bindings

  <<key-bindings>>

  ;;; Bongo settings

  <<bongo-settings>>

  ;;; Elfeed settings

  <<elfeed-settings>>
  <<elfeed-bongo>>
#+END_SRC
